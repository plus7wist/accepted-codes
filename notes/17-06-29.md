[TOC]

## DFS
### 计算连通分量

DFS到底一次可以求出一个连通分量。所以对图上未访问的点不断DFS可以求得图中所有连通分量。

```c++
vector<int>G[maxn];int vis[maxn];int cc;int n;
void dfs(int u)
{
    vis[u]=1;
    //previsit(u);
    int d=G[u].size();
    for(int i=0;i<d;i++)
    {
        int v=G[u][i];
        if(!vis[v]) dfs(v);
    }
    //postvisit(u);
}
void find_cc()
{
    cc=0;
    memset(vis,0,sizeof(vis));
    for(int i=0;i<n;i++)
        if(!vis[i])
        dfs(i),cc++;
}
```
### 判断二分图

0=未着色，1=黑，2=白

```c++
bool isbip(int u)
{
    int d=G[u].size();
    for(int i=0;i<d;i++)
    {
        int v=G[u][i];
        if(color[v]==color[i]) return 0;
        if(!color[v])
        {
            color[v]=3-color[i];
            if(!isbip(v)) return 0;
        }
    }
    return 1;
}
```
### 无向图的割顶和桥

对于无向图G,如果删除某个点u后，连通分量数目增加，称u为图的**割顶**，对于连通图，割顶就是删除之后使图不再连通的点。
DFS森林中的边称为树边，第一次处理时从后代指向祖先的边称为**反向边**。
**定理**：在无向连通图G的DFS树中，非根结点u是g的**割顶**当且仅当u存在一个子节点V,使得V及其所有后代都没有反向边连回u的祖先。
设pre(u)为开始访问结点u时的时间戳（全局访问数的值；易知，在DFS树中祖先的pre值一定比后代要小），设low(u)为u及其后代所能连回的最早的祖先的pre值，则上述定理可以简写为low(v)>=pre(u)。
作为一种特殊情况，如果v的后代只能连回v自己(low(v)>pre(u))，则(u,v)是**桥**。

```c++
vector<int>G[maxn];
vector<pair<int,int> >bridges;
int iscut[maxn];int pre[maxn];int low[maxn];
int dfs_clock=0;
int dfs(int u,int fa)
{
    int lowu=pre[u]=++dfs_clock;
    int child=0;int sz=G[u].size();
    for(int i=0;i<sz;i++)
    {
        int v=G[u][i];
        if(!pre[v])
        {
            child++;
            int lowv=dfs(v,u);
            lowu=min(lowu,lowv);
            if(lowv>=pre[u])
            {
                iscut[u]=1;
                if(lowv!=pre[u])bridges.push_back(pair<int,int>(v,u));
            }
        }
        else if(pre[v]<pre[u]&&v!=fa)//visited,less pre,not father(back edge)
            lowu=min(lowu,pre[v]);
    }
    if(fa<0&&child==1) iscut[u]=0;
    low[u]=lowu;
    return lowu;
}
```
### 无向图的双联通分量

对于一个连通图，如果任意两点至少存在两条哈密顿路径，则这个图是**点-双连通**（一般简称为双连通）的。这个要求等价于任意两条边都在同一个简单环中，即**无割顶**。
类似地，如果任意两点至少存在两条欧拉路径，则这个图是**边-双连通**的，这个要求等价于每条边都至少在一个简单环中，即**无桥**。
点-双连通的极大子图称为**双连通分量**，不同双连通分量最多只有一个公共点，且它一定是割顶。而任意割顶都是至少两个不同双连通分量的公共点。
同理，边-双连通的极大子图称为**边-双连通分量**，除了桥不属于任何一个边-双连通分量，其他每条边恰好属于一个边-双连通分量。

求点-双联通分量算法：
```c++
int pre[maxn],iscut[maxn],bccno[maxn],dfs_clock,bcc_cnt;
vector<int>G[maxn],bcc[maxn];
struct Edge
{
    int u;int v;
};
stack<Edge>S;
int dfs(int u,int fa)
{
    int lowu=pre[u]=++dfs_clock;
    int child=0;
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        Edge e=(Edge){u,v};
        if(!pre[v])
        {
            S.push(e);
            child++;
            int lowv=dfs(v,u);
            lowu=min(lowu,lowv);
            if(lowv>=pre[u])//find new cut
            {
                iscut[u]=1;
                bcc_cnt++;bcc[bcc_cnt].clear();//initialize current bcc
                while(1)
                {
                    Edge x=S.top();S.pop();//last visited edge
                    if(bccno[x.u]!=bcc_cnt)//point not in bcc,add
                    {
                        bcc[bcc_cnt].push_back(x.u);
                        bccno[x.u]=bcc_cnt;
                    }
                    if(bccno[x.v]!=bcc_cnt)//point not in bcc,add
                    {
                        bcc[bcc_cnt].push_back(x.v);
                        bccno[x.v]=bcc_cnt;
                    }
                    if(x.u==u&&x.v==v) break;
                }
            }
            else if(pre[v]<pre[u]&&v!=fa)//back edge
            {
                S.push(e);
                lowu=min(lowu,pre[v]);
            }
        }
    }
    if(fa<0&&child==1) iscut[u]=0;
    return lowu;
}
void find_bcc(int n)
{
    memset(pre,0,sizeof(pre));
    memset(iscut,0,sizeof(iscut));
    memset(bccno,0,sizeof(bccno));
    dfs_clock=bcc_cnt=0;
    for(int i=0;i<n;i++)
    {
        if(!pre[i]) dfs(i,-1);
    }
}
```
求边-双连通分量：先求出图中所有的桥，再dfs一次，这次保证不经过桥即可