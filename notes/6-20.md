[TOC]

## 无根树转有根树
```c++
//vector<int>G[maxn]存放边
//主程序中p[root]=-1,dfs(root,-1);
void dfs(int u,int fa)//递归转化以u为根的子树，u的父节点为fa
{
    int d=G[u].size();
    for(int i=0;i<d;i++)
    {
        int v=G[u][i];
        if(v!=fa) dfs(v,p[v]=u);
    }
}
```
## 表达式树
```c++
const int maxn=1000;
int lch[maxn],rch[maxn];char op[maxn];
int nc=0;
int build_tree(char *s,int x,int y)//x,y为区间
{
    int c1=-1,c2=-1,p=0;//c1:最右加减号 c2:最右乘除号 p:括号标志
    int u;//结点标号
    if(y-x==1)
    {
        u=++nc;
        lch[u]=rch[u]=0,op[u]=s[x];
        return u;
    }
    for(int i=x;i<y;i++)
    {
        if(s[i]=='(') p++;
        else if(s[i]==')') p--;
        else if((s[i]=='+'||s[i]=='-')&&!p) c1=i;
        else if((s[i]=='*'||s[i]=='/')&&!p) c2=i;
      }
      if(c1<0) c1=c2;
      if(c1<0) return build_tree(s,x+1,y-1);
    u=++nc;
    lch[u]=build_tree(s,x,c1);
    rch[u]=build_tree(s,c1+1,y);
    op[u]=s[c1];
    return u;
}
```
### 例题:UVA12219

#### 题意

运算符均为二元的，且运算符和运算数均用1~4个小写字母表示。
消除公共表达式可以减少结点。输入一个结点数不超过50000的表达式，输出一个等价的，结点最少的图。

#### 分析

通过用Map把子树映射成编号，可把子树用字符串和其左右子树编号表示。从而可以用O(logn)的时间查找重复子树。通过把子树的字符串映射成hash值可以用O(1)的时间比较字符串。

比较恶心的一题，看了代码之后都错了好几次。卡时间，卡数据，卡读题。

#### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=50005;
char op[maxn<<3];//题意是最多50000个结点，不是字符串最长50000！开太小会RE
int vis[maxn];int nc;
char *p;int ks;
struct nodes
{
    string s;//结点用string存可简化很多
    int ls,rs;int nhash;
    bool operator <(const nodes &rhs) const
    {
        if(nhash!=rhs.nhash) return nhash<rhs.nhash;
        if(ls!=rhs.ls) return ls<rhs.ls;
        return rs<rhs.rs;
}
}node[maxn];
map<nodes,int>ids;//快速查找结点
void print(int cur)
{
    if(vis[cur])//访问过，打印编号
    {
        printf("%d",cur+1);
        return;
    }
    vis[cur]=1;
    printf("%s",node[cur].s.c_str());//string转char
    if(node[cur].ls!=-1)//有子树
    {
        printf("(");
        print(node[cur].ls);
        printf(",");
        print(node[cur].rs);
        printf(")");
    }
}
int build_tree()
{
    int u=nc++;
    nodes &cur=node[u];
    cur.ls=-1;cur.rs=-1;cur.nhash=0;cur.s="";
    while(isalpha(*p))
    {
        cur.s.push_back(*p);
        cur.nhash=cur.nhash*27+*p-'a'+1;//这个hash函数选择得不好会被卡数据
        p++;
    }

    if(*p=='(')//有子树
    {
        //cout<<p<<endl;
        p++;
        cur.ls=build_tree();
        p++;
        cur.rs=build_tree();
        p++;
    }

    if(ids.count(cur)!=0)//旧结点
    {
        u--,nc--;
        return ids[cur];
    }
    return ids[cur]=u;//新增结点
}
int main()
{
    //freopen("test.txt","r",stdin);
    int t;scanf("%d",&t);
    for(ks=1;ks<=t;ks++)
    {
        nc=0;ids.clear();memset(vis,0,sizeof(vis));
        scanf("%s",op);
        p=op;//存放当前打印位置的全局指针
        int u=build_tree();
        print(u);
        printf("\n");
    }
    return 0;
}
```

## Kruskal

```c++
const int maxm=1005;int n;int m;
int father[maxm];int edges[maxm];int weight[maxm];
int from[maxm];int to[maxm];
int cmp(int a,int b){return weight[a]<weight[b];}
int look(int x){return father[x]==x?x:father[x]=look(father[x]);}
int Kruskal()
{
    int ans=0;
    for(int i=0;i<n;i++) father[i]=i;
    for(int i=0;i<m;i++) edges[i]=i;
    sort(edges,edges+m,cmp);
    for(int i=0;i<m;i++)
    {
        int e=edges[i];int ft=look(from[e]);int tt=look(to[e]);
        if(ft!=tt){ans+=weight[e];father[ft]=tt;}
    }
    return ans;
}
```

### 例题:UVA1395

#### 题意

求最大边与最小边之差（苗条度）尽量小的最小生成树。结点不超过100个。

#### 分析

把边按权值从小到大排序，对于一个连续的边集区间[L,R]，如果这些边使得n个点全部连通，则一定存在一个苗条度不超过W[R]-W[L]的生成树。

从小到大枚举L，对于每个L，从小到大枚举R，同时用并查集将新进入[L,R]的边两端的点合并成一个集合。当所有点连通时，停止枚举R，换下一个L(并且把R重置为L)继续枚举。

#### 代码

```c++
//这题数组开小了UVA判的是WA？？
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF=0x3f3f3f3f;
const int maxm=5005;int n;int m;
int father[maxm];int edges[maxm];int weight[maxm];
int from[maxm];int to[maxm];
int cmp(int a,int b){return weight[a]<weight[b];}
int look(int x){return father[x]==x?x:father[x]=look(father[x]);}
int solve()
{
    for(int i=0;i<m;i++) edges[i]=i;
    sort(edges,edges+m,cmp);
    int ans=INF;
    for(int l=0;l<m;l++)
    {
        for(int i=0;i<=n;i++) father[i]=i;
        int nn=n;
        for(int r=l;r<m;r++)
        {
            int e=edges[r];int ft=look(from[e]);int tt=look(to[e]);
            if(ft!=tt)
            {
                father[ft]=tt;
                if(--nn==1)//合并了n-1次说明全部连通，计算l,r边之差
                {
                    ans=min(ans,abs(weight[edges[r]]-weight[edges[l]]));
                    break;
                }
            }
        }
    }
    if(ans==INF) ans=-1;
    return ans;
}
int main()
{
    //freopen("test.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int a,b,c;
    while(scanf("%d%d",&n,&m)==2&&n)
    {
        for(int i=0;i<m;i++)
        {
            scanf("%d%d%d",&a,&b,&c);
            from[i]=a;to[i]=b;weight[i]=c;
        }
        int ans=solve();
        printf("%d\n",ans);
    }
    return 0;
}
```

### 例题:UVA1151

#### 题意



#### 分析



#### 代码