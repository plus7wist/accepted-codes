我真的很想做题……但是steam暑期特惠，不把刚买的游戏都装了试一遍，以后就很难退款了（垃圾育碧，垃圾uplay，还好steam客服马上就帮我把退的钱转进银行卡了）

## 树状数组支持的操作

树状数组解决的基本问题是 单点更新，成端求和。

**更新**：修改单个元素,O(logn)

**求和**：统计给定区间内元素之和，O(logn)

## 树状数组的结构

**物理性质**：树状数组以数组的形式存放，占用内存中连续的物理空间。

**逻辑性质**：树状数组的各元素之间存在父子关系。

对于两个数组下标$$x,y(x<y)$$，如果$$x+2^k=y$$(k等于x的二进制表示中末尾0的个数)，那么定义$$(y, x)$$为一组树上的父子关系，其中y为父结点，x为子结点。

![](http://images.cppblog.com/cppblog_com/menjitianya/szsz_2.png)



树状数组定义的树形关系如图，其中A为普通数组，C为树状数组。

从图中可以看出，它表示的其实是一段原数组A的连续区间和。右区间是很明显的，C[i]表示的区间的最后一个元素一定是A[i]。而对于左区间，从图上可以看出，其实就是顺着C[i]的最左儿子一直找直到找到叶子结点，那个叶子结点就是C[i]表示区间的第一个元素。

更加具体的，如果i的二进制表示为 ABCDE1000，那么它最左边的儿子就是 ABCDE0100，这一步是通过结点父子关系的定义进行逆推得到，并且这条路径可以表示如下：
ABCDE1000 => ABCDE0100 => ABCDE0010 => ABCDE0001

那么我们发现，如果用k来表示i的二进制末尾0的个数，Ci能够表示的A数组的区间的元素个数为$$2^k$$，又因为区间和的最后一个数一定是A[i]，所以有如下公式：
$$Ci=\sum_{i-2^k+1<=j<=i}Aj$$
（将j的两个端点相减+1 等于2^k）

**lowbit(x)**表示的是x末尾0的个数，通过以上证明可以看出，lowbit函数实际上就是表示树状数组祖先和子孙结点关系的一个函数。

应用此函数时通常使用一种O(1)的求法。

```c++
int lowbit(int x){return x & -x;}
```

 x的补码由三部分组成：(0)(X1X2…Xn-k-1)(k个0)其中Xn-k-1为1，因为末尾是k个0，如果它为0，那就变成k+1个0了。
-x的补码也是由三部分组成(1)(Y1Y2…Yn-k-1)(k个0)其中Yn-k-1为1，其它的Xi和Yi相加为1。
 那么 x & (-x) 也就显而易见了，由两部分组成 (1)(k个0)，表示成十进制为 $$2^k$$。


## 求和操作

求和的过程：每用lowbit函数在C数组往回走一层，就能求得当前询问区间内一部分的区间和（访问的子结点~移动前位于的结点）。访问所有子孙结点并将C值相加，即可求得询问结点到起始结点的完整A区间和。

```c++
int sum(int x)
{
    int sum=0;
    for(int i=x;i;i-=lowbit(x))
    {
        sum+=c[i];
    }
    return sum;
}
```


## 更新操作

A[i]的改变只会影响C[i]及其祖先结点，也就是每次add(i, v)，我们只要更新C[i]以及它的祖先结点直到最后一个祖先为止。

```c++
void add(int x,int v)
{
    for(int i=x;i<=n;i+=lowbit(i))
    {
        c[i]+=[v];
    }
}
```
